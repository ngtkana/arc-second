## ARC 098 C - Multiple Gift

$X, 2X, 4X, \dots$ を $Y$ 以下で切ったときの要素数です。


## ARC 098 D - Wide Flip

$K$ 以上のみで操作すると、$K$ が $n / 2$ 以下ならばなんでも作ることができます。
そうでなければ、$[n - k, k[$ を添字とする部分列が、要素が互いに等しいです。
逆にそういうものならばなんでも作れます。


## ARC 098 E - Papple Sort

不可能なのは、奇数個ある文字が $2$ 種類以上あるばあいです。
それ以外は必ず作れます。

まず、同じ種類の文字の相対的な位置関係を変える必要がないことに注意すると、
各文字が左側か真ん中の $1$ 文字なのか、右側なのかが決まります。
それを実現するために必要最低限の移動をしましょう。

それが済んだら、左側と右側が整合するようにしましょう。
左側を入れ替えて右側の reverse になればよいです。
右側を reverse しておきましょう。これも先ほどと同じようにどの文字がどこに行くべきかが決まります。
この置換の転倒数をセグツリーで計算です。


## ARC 098 F - Christmas Tree

### $A$ を最小化しましょう。

クリスマスパスの端点を見ていきましょう。
次数が奇数の頂点（印をつけておきましょう）はかならず $1$ 個以上の端点になりますから、$A$ はそういうものの半分は必要です。

逆に、印のついた頂点がぴったり $1$ 回端点になって、他は端点にならないようなものが構成できると良いです。
そういうものが構成できたとすると、それは印のついた頂点同士の完全マッチングを与えます。
さらにそれらの間のパスが、辺素にグラフ全体を覆っています。
逆にそういうマッチングがあれば、マッチの間に辺を張ることで構成ができます。

さて、そのように辺素な被覆を構成したいのですが、それは次のように作ると良いです。
まず全体がパスの場合は例外です。そうでないとします。
まず $2$ つの印のついた頂点であって、その間に印のついた頂点のなく、また字数が $4$ 以上の頂点が $1$ こしかないようなペアを選んでマッチングします。
そしてこのパスを、字数 $4$ 以上の頂点ひとつを残して消してしまうと、小さな木になります。
このように帰納的に構成していくと良いです。

### $B$ を最小化しましょう。

そのまえに、辺素被覆条件について考えましょう。
まず被覆についてなのですが、辺を $1$ 本眺めましょう。
すると、その左側に属する頂点の次数の合計は奇数で、右側もそうですから、どうマッチングしてもこの辺を通ることになります。
したがって、被覆条件は自動的に成り立ちますから、気にする必要はありません。
すなわち、気にするべきは辺素条件のみです。

#### 二分探索をしましょう。決め打ちして DP です。

二分探索です。
$B$ を決め打ちしたときに、距離がすべて $B$ 以下となるように、辺素条件を満たしながらマッチングできるかを試しましょう。
根を決めて木 DP です。根でない頂点 $x$ の部分木を見ましょう。先述のとおり、部分木の中には、印のついた頂点が奇数個あります。
これらを、$1$ つ以外完全にマッチさせる必要があります。なぜならばこの部分木から出ていけるパスはひとつだけだからです。

$\mathtt { dp } _ x$ は $x$ の部分木に含まれる印のついた頂点を、距離 $B$ 以内を守りながら一つを残してすべてマッチさせたときの、
ぼっち頂点の深さの最小値です。そもそもこれが守れない場合は、二分探索のこのトライが失敗です。

#### DP の遷移を考えましょう。

$x$ に印がついていない場合を考えます。このとき、$x$ の子は（親がいるので）奇数個です。
子の DP の値を昇順に $d _ 0, d _ 1, \dots, d _ { k - 1 }$ と置きましょう。
そして、それらに $1$ を足したものを $\hat d _ 0, \hat d _ 1, \dots, \hat d _ { k - 1 }$ とおきます。
すると、$\mathtt { dp }$ は、$\hat d _ i$ であって、残りをうまくマッチングすると $B$ 以下にできるようなものの中で最小です。
マッチングに使うものがわかっていれば、最小・最小から貪欲にマッチしていくと良いです。
これは、$i$ を二分探索することでできます。

さて、今度は印がついている場合なのですが、この場合は自分自身の $\hat d$ が $0$ だと思うと、おなじことです。
さらに根の場合なのですが、根の場合は問答無用、すべてマッチングする必要があります。
最大・最小から貪欲にマッチしてみて、$B$ を超えるかどうかを見ると良いのですが、
そうしなくとも、自分が深さ $0$ の印だと思って同じことをして、
結果が $0$ になれば OK のようにすると、実装が共通化できます。


#### 遷移を線形で

ちょっと厳しそうです。
まずソートする時点ででめなのですが、一旦目をつぶりましょうか。

最初だけ計算すれば、あとはマッチの変更は毎回 $1$ 箇所なので、そこだけ変えれば間に合うのではないかです。
少なくともそのままは難しいです。というのも、マッチの重みの集合は更新できても最小は即座にはわからないからです。
そこでスライド最小値です。

というわけで、ソートさえできればできますが、ちょっと大変です。
