# C - HSI

$(1900 (n - m) + 100 m) \cdot 2 ^ m$ です。

# D - ABS

先手は完封することで $\lvert a _ { N - 1 } - W \rvert$ を達成可能です。
また一抹の慈悲を施すことで $\lvert a _ { N - 2 } -  a _ { N - 1 }$ も達成可能です。
つまりこれらの max が達成可能です。

一方後手も完封さえされなければ後者が達成可能です。
もちろん完封された場合は前者が達成可能です。
したがってどちらかは達成できますから、max が達成できます。

# E - MUL

問題名に答えが書いてあります。
Moyasu Ume-Lu です！


# F - NRE

`0` は白色、`1` は黒色としましょう。

## イメージと着想

順番に区間を挿入して増分を管理したいのですが、
一般にはこのようになっていますから、
今までに入れた場所一覧のようなものを管理する必要があり、
それはとてもできそうにありません。

```
 ## #### ## ######
      l------------r
```

しかし、「必ず」このような形になっているならば、
右端だけがわかれば良いです。

```
 ## ############
      l------------r
```

`l` でソートをすると、ある棒よりも前に見たものは必ず始まりが `l` or less ですから、とても嬉しいということがわかります。


## 解法

まずは二乗時間で解きましょう。

$0 \le i \le j \le n$ に対して、$a _ { i, j }$ を次のように定義します。
それは $[0, i[$ との交わりが非空であるような棒の使い方であって、
$$
    j = \max \left ( i,  \text { 黒の添字の最大値 } + 1 \right )
$$
を満たすような選び方を考えたときのハミング距離の最小値です。

### 遷移

さて、$a _ { i, j }$ から $a _ { i + 1, k }$ への寄与を計算しましょう。
$k = i + 1$ かどうかで変わります。
いくつかの区間を選ぶのですが、包含関係にあるものを複数選んでも良いことはありませんから、
一つ以下の場合だけ考えると良いです。


#### $k \lt i + 1$ のとき

このときには、本当にここで終わる必要があることに注意です。

まず $j = k$ ならばどの区間も選ばないのが正解です。
$j > k$ のように縮んでしまうミラクルは起きません。
$j < k$ のときにはちょうど $k$ (exclusive) で終わる区間があるときのみ達成可能であり、
このとき $[j, k[$ を新たに黒くした分の追加コストがかかります。

#### $k = i + 1$ のとき

これは、以下の 3 つの場合が該当します。
とくに 2. が非自明なのですが、$a$ の第二添字は第一添字で `change_max` していますから、
$i$ を塗らなくても昇格ができます。
1. $j = i$ のときに $i$ に黒を塗った場合
2. $j = i$ のときに何もしなかった場合
3. $j = i + 1$ のときに何もしなかった場合

### 実装・インライン化

クエリの区間を順番に見ていって、$[l, r[$ の各要素を先述の $j$ とするようなものを書けばよいです。
すると、先述の $k$ が $r$ です。

$$
    a _ { l, r } \leftarrow a _ { l, j } + \mathrm { cost } _ { j, r }
$$

第二引数が増える方にしか作用していませんから、ほとんどそのままインライン化ができます。

たとえば $[0, 1[, [0, 2[$ をこの順に処理するとこのように連鎖が起きてしまいます。
なのですが、今回は数え上げではありませんから、よくよく考えると気にしなくてよいです。
$$
    a _ { 0, 1 } \leftarrow a _ { 0, 0 } + \mathrm { cost } _ { 0, 1 } \\
    a _ { 0, 2 } \leftarrow a _ { 0, 1 } + \mathrm { cost } _ { 1, 2 } \\
$$

### 高速化

$a ' _ { j } = a _ { j } - \mathrm { cost } _ { j }$ のようなことをするとセグツリーに乗ります。

